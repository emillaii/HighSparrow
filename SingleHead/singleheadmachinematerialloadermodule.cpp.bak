#include "SingleHead/singleheadmachinematerialloadermodule.h"
#include <QMessageBox>
#include <QElapsedTimer>
SingleHeadMachineMaterialLoaderModule::SingleHeadMachineMaterialLoaderModule(QString name)
:ThreadWorkerBase (name)
{

}

void SingleHeadMachineMaterialLoaderModule::Init(SingleHeadMachineMaterialPickArm *_pick_arm,
                                                 MaterialTray* _sensorTray,
                                                 MaterialTray* _lensTray,
                                                 MaterialTray* _rejectTray,
                                                 VisionLocation* _sensor_vision,
                                                 VisionLocation* _sensor_vacancy_vision,
                                                 VisionLocation* _sut_vision,
                                                 VisionLocation* _sut_sensor_vision,
                                                 VisionLocation* _sut_product_vision,
                                                 VisionLocation* _lens_vision,
                                                 VisionLocation* _lens_vacancy_vision,
                                                 VisionLocation* _lut_vision,
                                                 VisionLocation* _lut_lens_vision,
                                                 VisionLocation* _reject_tray_vacancy_vision,
                                                 XtVacuum* _sutVacuum,
                                                 XtVacuum* _lutVacuum)
{
    this->pick_arm = _pick_arm;
//    this->pick_arm->parent = this;
    this->sensorTray = _sensorTray;
    this->lensTray = _lensTray;
    this->rejectTray = _rejectTray;
    this->sensor_vision = _sensor_vision;
    this->sensor_vacancy_vision = _sensor_vacancy_vision;
    this->sut_vision = _sut_vision;
    this->sut_sensor_vision = _sut_sensor_vision;
    this->sut_product_vision = _sut_product_vision;
    this->lens_vision = _lens_vision;
    this->lens_vacancy_vision = _lens_vacancy_vision;
    this->lut_vision = _lut_vision;
    this->lut_lens_vision = _lut_lens_vision;
    this->reject_tray_vacancy_vision = _reject_tray_vacancy_vision;
    this->sut_vacuum = _sutVacuum;
    this->lut_vacuum = _lutVacuum;
}

void SingleHeadMachineMaterialLoaderModule::loadJsonConfig(QString file_name)
{

}

void SingleHeadMachineMaterialLoaderModule::saveJsonConfig(QString file_name)
{

}

void SingleHeadMachineMaterialLoaderModule::performHandling(int cmd)
{
    emit sendHandlingOperation(cmd);
    qInfo("emit performHandling %d",cmd);
}


//bool SingleHeadMachineMaterialLoaderModule::checkTrayNeedChange()
//{
//    if(sensorTray->isTrayNeedChange(0))
//        return true;
//    return false;
//}

bool SingleHeadMachineMaterialLoaderModule::moveToNextSensorTrayPos(int tray_index)
{
    qInfo("moveToNextTrayPos tray_index %d",tray_index);
    bool result = sensorTray->findNextPositionOfInitState(tray_index);
    if(result)
        result &=  pick_arm->move_XY_Synic(sensorTray->getCurrentPosition(tray_index));
    if(!result)
        AppendError(QString(u8"移动到%1盘下一个位置失败").arg(tray_index == 0?"sensor":"成品"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToSUTPRPos(bool is_local, bool check_softlanding)
{
    qInfo("moveToSUTPRPos is_local %d",is_local);
    bool result;
    result =  pick_arm->move_XmY_Synic(sut_pr_position.ToPointF(),check_softlanding);
    if(!result)
        AppendError(QString("移动SPA到SUT位置失败%1").arg(is_local));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::performSensorPR()
{
    qInfo("performSensorPR");
    bool result = sensor_vision->performPR(pr_offset);
    if(result)
        AppendError(QString(u8"执行料盘sensor视觉失败!"));
    return  result;
}

bool SingleHeadMachineMaterialLoaderModule::performSensorVacancyPR()
{
    qInfo("performVacancyPR");
    bool result = sensor_vacancy_vision->performPR(pr_offset);
    if(result)
        AppendError(QString(u8"执行料盘空位视觉失败!"));
    return  result;
}

bool SingleHeadMachineMaterialLoaderModule::performSUTPR()
{
    qInfo("performSUTPR");
    bool result = sut_vision->performPR(pr_offset);
    if(result)
        AppendError(QString(u8"执行SUT视觉失败!"));
    return  result;
}

bool SingleHeadMachineMaterialLoaderModule::performSUTSensorPR()
{
    qInfo("performSUTSensorPR");
    bool result = sut_sensor_vision->performPR(pr_offset);
    if(result)
        AppendError(QString(u8"执行SUT上的sensor视觉失败!"));
    return  result;
}

bool SingleHeadMachineMaterialLoaderModule::performSUTProductPR()
{
    qInfo("performSUTProductPR");
    bool result = sut_product_vision->performPR(pr_offset);
    if(result)
        AppendError(QString(u8"执行SUT视觉失败!"));
    return  result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToPicker2WorkPos(bool check_softlanding)
{
    PrOffset temp(sensor_suction_offset.X() - pr_offset.X,sensor_suction_offset.Y() - pr_offset.Y,pr_offset.Theta);
    qInfo("moveToPicker2WorkPos offset:(%f,%f,%f)",temp.X,temp.Y,temp.Theta);
    bool result = pick_arm->stepMove_XmYT2_Synic(temp.X,temp.Y,temp.Theta,check_softlanding);
    if(result)
        AppendError(QString(u8"去2号吸头工作位置(step x %1,y %2,t %3)失败!").arg(temp.X).arg(temp.Y).arg(temp.Theta));
    return  result;
}


bool SingleHeadMachineMaterialLoaderModule::picker2SearchZ(double z, bool is_open, int time_out,int picker)
{
    qInfo("picker2SearchZ z %f is_open %d timeout %d",z,is_open,time_out);
    bool result = pick_arm->ZSerchByForce(picker,parameters.vcm2Svel(),parameters.vcm2PickForce(),z,parameters.vcm2Margin(),parameters.vcm2FinishDelay(),is_open,false,time_out);
    result &= pick_arm->ZSerchReturn(picker,time_out);
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker1SearchZ(double z, bool is_open, int time_out,int picker)
{
    qInfo("picker1SearchZ z %f is_open %d timeout %d",z,is_open,time_out);
    QElapsedTimer timer; timer.start();
    bool result = pick_arm->ZSerchByForce(picker,parameters.vcm1Svel(),parameters.vcm1PickForce(),z,parameters.vcm1Margin(),parameters.vcm1FinishDelay(),is_open,false,time_out);
    qInfo("ZSerchByForce: %d", timer.elapsed()); timer.restart();
    result &= pick_arm->ZSerchReturn(picker,time_out);
    qInfo("ZSerchReturn: %d", timer.elapsed()); timer.restart();
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2SearchSutZ(double z, QString dest, QString cmd, bool is_open, int time_out)
{
    qInfo("picker2SearchSutZ z %f dest %s cmd %s is_open %d time_out %d",z,dest.toStdString().c_str(),cmd.toStdString().c_str(),is_open,time_out);
    bool result = pick_arm->move_XmeYe_Z2_XmY(z - parameters.escapeHeight(),parameters.escapeX(),parameters.escapeY());
    if(result)
    {
        result = pick_arm->ZSerchByForce(1,parameters.vcm2Svel(),parameters.vcm2PickForce(),z,parameters.vcm2Margin(),parameters.vcm2FinishDelay(),is_open,false,time_out);

        //sut_vacuum
        sut_vacuum->Set(1);
        QThread::msleep(200);
        result &= pick_arm->ZSerchReturn(1,time_out);
    }
    result &= pick_arm->motor_vcm2->MoveToPosSync(0);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2SearchSutZ2(double z, QString dest, QString cmd, bool is_open, int time_out)
{
    qInfo("picker2SearchSutZ2 z %f dest %s cmd %s is_open %d time_out %d",z,dest.toStdString().c_str(),cmd.toStdString().c_str(),is_open,time_out);
    bool result = pick_arm->motor_vcm2->MoveToPosSync(z-parameters.escapeHeight());
    if(result)
    {
        result = pick_arm->ZSerchByForce(1,parameters.vcm2Svel(),parameters.vcm2PickForce(),z,parameters.vcm2Margin(),parameters.vcm2FinishDelay(),is_open,false,time_out);
        //sut_vacuum
        sut_vacuum->Set(0);
        QThread::msleep(200);
        result &= pick_arm->ZSerchReturn(1,time_out);
    }
    result &= pick_arm->move_XmeYe_Z2_XmY(0,parameters.escapeX(),parameters.escapeY());
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker1SearchSutZ2(double z, QString dest, QString cmd, bool is_open, int time_out)
{
    qInfo("picker2SearchSutZ2 z %f dest %s cmd %s is_open %d time_out %d",z,dest.toStdString().c_str(),cmd.toStdString().c_str(),is_open,time_out);
    bool result = pick_arm->motor_vcm2->MoveToPosSync(z-parameters.escapeHeight());
    if(result)
    {
        result = pick_arm->ZSerchByForce(0,parameters.vcm1Svel(),parameters.vcm1PickForce(),z,parameters.vcm1Margin(),parameters.vcm1FinishDelay(),is_open,false,time_out);
        //sut_vacuum
        sut_vacuum->Set(0);
        QThread::msleep(200);
        result &= pick_arm->ZSerchReturn(0,time_out);
    }
    result &= pick_arm->move_XmeYe_Z2_XmY(0,parameters.escapeX(),parameters.escapeY());
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker1SearchSutZ(double z, QString dest, QString cmd, bool is_open, int time_out)
{
    qInfo("picker1SearchSutZ z %f dest %s cmd %s is_open %d time_out %d",z,dest.toStdString().c_str(),cmd.toStdString().c_str(),is_open,time_out);
    bool result = pick_arm->move_XmeYe_Z1_XmY(z - parameters.escapeHeight(),parameters.escapeX(),parameters.escapeY());
    if(result)
    {
        result = pick_arm->ZSerchByForce(0,parameters.vcm1Svel(),parameters.vcm1PickForce(),z,parameters.vcm1Margin(),parameters.vcm1FinishDelay(),is_open,false,time_out);

        //sut_vacuum
        sut_vacuum->Set(0);
        QThread::msleep(200);
        result &= pick_arm->ZSerchReturn(0,time_out);
    }
    result &= pick_arm->motor_vcm1->MoveToPosSync(0);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2PickSensorFormTray(int time_out)
{
    qInfo("pickTraySensor time_out %d",time_out);
    bool result = picker2SearchZ(pick_arm->parameters.pickSensorZ(),true,time_out, 1);
    if(!result)
        AppendError(QString(u8"从sensor盘取sensor失败"));
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker1PickSensorFormTray(int time_out)
{
    qInfo("pickTraySensor time_out %d",time_out);
    bool result = picker1SearchZ(pick_arm->parameters.pickSensorZ(),true,time_out, 0);
    if(!result)
        AppendError(QString(u8"从sensor盘取sensor失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker1PlaceSensorToSUT(QString dest, int time_out)
{
    qInfo("placeSensorToSUT dest %s time_out %d",dest.toStdString().c_str(),time_out);
   bool result = picker1SearchSutZ(pick_arm->parameters.placeSensorZ(),dest,"vacuumOnReq",false,time_out);
    if(!result)
        AppendError(QString(u8"放sensor到SUT%1失败").arg(dest=="remote"?1:2));
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker2PlaceSensorToSUT(QString dest, int time_out)
{
    qInfo("placeSensorToSUT dest %s time_out %d",dest.toStdString().c_str(),time_out);
   bool result = picker2SearchSutZ(pick_arm->parameters.placeSensorZ(),dest,"vacuumOnReq",false,time_out);
    if(!result)
        AppendError(QString(u8"放sensor到SUT%1失败").arg(dest=="remote"?1:2));
    return result;
}


bool SingleHeadMachineMaterialLoaderModule::picker2PickNGSensorFormSUT(int time_out)
{
    qInfo("picker2PickNGSensorFormSUT time_out %d",time_out);
    bool result = picker2SearchSutZ2(pick_arm->parameters.pickNgSensorZ(),"dummy","vacuumOffReq",true,time_out);
    if(!result)
        AppendError(QString(u8"从SUT取NGsenor失败"));
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker1PickNGSensorFormSUT(QString dest, int time_out)
{
    qInfo("pickSUTSensor dest %s time_out %d",dest.toStdString().c_str(),time_out);
    bool result = picker1SearchSutZ2(pick_arm->parameters.pickNgSensorZ(),dest,"vacuumOffReq",true,time_out);
    if(!result)
        AppendError(QString(u8"从SUT%1取NGsenor失败").arg(dest=="remote"?1:2));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker1PickProductFormSUT(QString dest, int time_out)
{
    qInfo("pickSUTProduct dest %s time_out %d",dest.toStdString().c_str(),time_out);
    bool result = picker1SearchSutZ2(pick_arm->parameters.pickProductZ(),dest,"vacuumOffReq",true,time_out);
    if(!result)
        AppendError(QString(u8"从SUT%1取成品失败").arg(dest=="remote"?1:2));
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker2PickProductFormSUT(QString dest, int time_out)
{
    qInfo("pickSUTProduct dest %s time_out %d",dest.toStdString().c_str(),time_out);
    bool result = picker2SearchSutZ2(pick_arm->parameters.pickProductZ(),dest,"vacuumOffReq",true,time_out);
    if(!result)
        AppendError(QString(u8"从SUT%1取成品失败").arg(dest=="remote"?1:2));
    return result;
}


bool SingleHeadMachineMaterialLoaderModule::picker1PlaceNGSensorToTray(int time_out)
{
    qInfo("placeSensorToTray time_out %d",time_out);
    bool result = picker2SearchZ(pick_arm->parameters.placeNgSensorZ(),false,time_out, 0);
    if(!result)
        AppendError(QString(u8"将Ngsensor放入NG盘失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2PlaceSensorToTray(int time_out)
{
    qInfo("placeSensorToTray time_out %d",time_out);
    bool result = picker2SearchZ(pick_arm->parameters.placeNgSensorZ(),false,time_out, 1);
    if(!result)
        AppendError(QString(u8"将Ngsensor放入NG盘失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2PlaceNGSensorToTray(int time_out)
{
    qInfo("placeSensorToTray time_out %d",time_out);
    bool result = picker2SearchZ(pick_arm->parameters.placeNgSensorZ(),false,time_out, 1);
    if(!result)
        AppendError(QString(u8"将Ngsensor放入NG盘失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2PlaceProductToTray(int time_out)
{
    qInfo("placeProductToTray time_out %d",time_out);
    bool result = picker2SearchZ(pick_arm->parameters.placeProductZ(),false,time_out,0);
    if(!result)
        AppendError(QString(u8"将成品放入成品盘失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2MeasureHight(bool is_tray, bool is_product,bool is_ng)
{
    qInfo("picker2MeasureHight is_tray %d is_product %d",is_tray,is_product);
    if(pick_arm->ZSerchByForce(1,parameters.vcm2Svel(),parameters.vcm2PickForce(),true))
    {
        QThread::msleep(100);
        if(!emit sendMsgSignal(tr(u8"提示"),tr(u8"是否应用此高度:%1").arg(pick_arm->GetSoftladngPosition(false, 1)))){
            return true;
        }
        if(is_tray)
        {
            if(is_product)
                pick_arm->parameters.setPlaceProductZ(pick_arm->GetSoftladngPosition(false, 1));
            else{
                if(is_ng){
                    pick_arm->parameters.setPlaceNgSensorZ(pick_arm->GetSoftladngPosition(false, 1));
                }
                else{
                    pick_arm->parameters.setPickSensorZ(pick_arm->GetSoftladngPosition(false, 1));
                }
            }
        }
        else
        {
            if(is_product)
                pick_arm->parameters.setPickProductZ(pick_arm->GetSoftladngPosition(false, 1));
            else
            {
                if(is_ng)
                    pick_arm->parameters.setPickNgSensorZ(pick_arm->GetSoftladngPosition(false, 1));
                else
                    pick_arm->parameters.setPlaceSensorZ(pick_arm->GetSoftladngPosition(false, 1));
            }

        }
        return true;
    }
    AppendError(QString(u8"2号吸头测高失败"));
    return false;
}

bool SingleHeadMachineMaterialLoaderModule::moveToSensorTrayPos(int index, int tray_index)
{
    qInfo("moveToTrayPos index %d tray_index %d",index,tray_index);
    bool result = pick_arm->move_XY_Synic(sensorTray->getPositionByIndex(index,tray_index));
    if(!result)
        AppendError(QString(u8"移动到%1盘%1号位置失败").arg(tray_index == 0?"sensor":"成品").arg(index));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToSensorTrayPos(int tray_index)
{
    qInfo("moveToTrayPos tray_index %d",tray_index);
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(sensorTray->getCurrentPosition(tray_index),false);
    if(!result)
        AppendError(QString(u8"移动到%1盘当前位置失败").arg(tray_index == 0?"sensor":"成品"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToSensorTrayStartPos(int tray_index)
{
    qInfo("moveToStartPos%d",tray_index);
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(sensorTray->getStartPosition(tray_index),false);
    if(!result)
        AppendError(QString(u8"移动到%1盘起始位置失败").arg(tray_index == 0?"sensor":"成品"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToSensorTrayEndPos()
{
    qInfo("moveToTray1EndPos");
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(sensorTray->getEndPosition(),false);
    if(!result)
        AppendError(QString(u8"移动到sensor盘结束位置失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToNextLensTrayPos(int tray_index)
{
    qInfo("moveToNextTrayPos:%d",tray_index);
    if(lensTray->findNextPositionOfInitState(tray_index))
    {
        return  pick_arm->move_XYXmT1_Synic(lensTray->getCurrentPosition(tray_index),parameters.visionPositionX(),pick_arm->parameters.pickLensTheta());
    }
    return  false;
}

bool SingleHeadMachineMaterialLoaderModule::moveToLUTPRPos(bool check_softlanding)
{
    double theta = pr_offset.Theta;
    if (pick_arm->parameters.placeLensTheta() < 0) theta = -pr_offset.Theta;
    pr_offset.Theta = 0; //Reset the last pr result
    double target_t = pick_arm->motor_th1->GetFeedbackPos() + theta;
    return  pick_arm->move_XmYT1_Synic(lut_pr_position.X(),lut_pr_position.Y(),target_t,check_softlanding);
}

bool SingleHeadMachineMaterialLoaderModule::checkNeedChangeLensTray()
{
    if(lensTray->isTrayNeedChange(0)&&lensTray->isTrayNeedChange(1))
        return true;
    return false;
}

bool SingleHeadMachineMaterialLoaderModule::checkNeedChangeSensorTray()
{
    if(sensorTray->isTrayNeedChange(0)&&sensorTray->isTrayNeedChange(1))
        return true;
    return false;
}

bool SingleHeadMachineMaterialLoaderModule::performLensPR()
{
    qInfo("performLensPR");
    Sleep(500); //Position settling
    return  lens_vision->performPR(pr_offset);
}

bool SingleHeadMachineMaterialLoaderModule::performLensVacancyPR()
{
    return  lens_vacancy_vision->performPR(pr_offset);
}

bool SingleHeadMachineMaterialLoaderModule::performLUTPR()
{
    return lut_vision->performPR(pr_offset);
}


bool SingleHeadMachineMaterialLoaderModule::performLUTLensPR()
{
    return lut_lens_vision->performPR(pr_offset);
}



bool SingleHeadMachineMaterialLoaderModule::moveToPicker1WorkPos(bool check_softlanding)
{
    PrOffset temp(lens_suction_offset.X() - pr_offset.X,lens_suction_offset.Y() - pr_offset.Y,pr_offset.Theta);
    bool result = pick_arm->stepMove_XmYT1_Synic(temp.X,temp.Y,temp.Theta, check_softlanding);
    return  result;
}



bool SingleHeadMachineMaterialLoaderModule::picker1PickLensFormTray(int time_out)
{
    qInfo("pickTrayLens");
    bool result = picker1SearchZ(pick_arm->parameters.pickLensZ(),true,time_out,0);
    return result;
}
bool SingleHeadMachineMaterialLoaderModule::picker2PickLensFormTray(int time_out)
{
    qInfo("pickTrayLens");
    bool result = picker2SearchZ(pick_arm->parameters.pickLensZ(),true, time_out,1);
    return result;
}


bool SingleHeadMachineMaterialLoaderModule::picker1PlaceLensToLUT(int time_out)
{
    qInfo("placeLensToLUT");
    bool result = picker1SearchZ(pick_arm->parameters.placeLensZ(), false, time_out, 0);
    this->lut_vacuum->Set(true);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::picker2PickNGLensFormLUT(int time_out)
{
    qInfo("pickLUTLens");
    return picker2SearchZ(pick_arm->parameters.placeLensZ(),true,time_out,1);
}
bool SingleHeadMachineMaterialLoaderModule::picker1PickNGLensFormLUT(int time_out)
{
    QElapsedTimer timer; timer.start();
    qInfo("pickLUTLens");
    this->lut_vacuum->Set(false);
    qInfo("cp1: %d", timer.elapsed());
    bool ret = picker1SearchZ(pick_arm->parameters.placeLensZ(),true, time_out,0);
    qInfo("cp2: %d", timer.elapsed());
    return ret;
}

bool SingleHeadMachineMaterialLoaderModule::picker1PlaceNGLensToTray(int time_out)
{
    qInfo("placeLensToTray");
    return picker1SearchZ(pick_arm->parameters.pickLensZ(),false,time_out,0);
}
bool SingleHeadMachineMaterialLoaderModule::picker1PlaceLensToTray(int time_out)
{
    qInfo("placeLensToTray");
    return picker1SearchZ(pick_arm->parameters.pickLensZ(),false,time_out, 0);
}
bool SingleHeadMachineMaterialLoaderModule::picker2PlaceNGLensToTray(int time_out)
{
    qInfo("placeLensToTray");
    return picker2SearchZ(pick_arm->parameters.pickLensZ(),false,time_out,1);
}
bool SingleHeadMachineMaterialLoaderModule::picker2PlaceLensToTray(int time_out )
{
    qInfo("placeLensToTray");
    return picker2SearchZ(pick_arm->parameters.pickLensZ(),false,time_out,1);
}

bool SingleHeadMachineMaterialLoaderModule::picker1MeasureHight(bool is_tray,bool is_product)
{
    qInfo("measureHight speed: %f force: %f", parameters.vcm1Svel(), parameters.vcm1PickForce());
    if(pick_arm->ZSerchByForce(0,parameters.vcm1Svel(),parameters.vcm1PickForce(),true))
    {
        QThread::msleep(100);
        if(!emit sendMsgSignal(tr(u8"提示"),tr(u8"是否应用此高度:%1？").arg(pick_arm->GetSoftladngPosition()))){
            return true;
        }
        if(is_product){
            if(is_tray)
                pick_arm->parameters.setPlaceProductZ(pick_arm->GetSoftladngPosition());
            else
                pick_arm->parameters.setPickProductZ(pick_arm->GetSoftladngPosition());
        }else{
            if(is_tray)
                pick_arm->parameters.setPickLensZ(pick_arm->GetSoftladngPosition());
            else
                pick_arm->parameters.setPlaceLensZ(pick_arm->GetSoftladngPosition());
        }
        return true;
    }
    return false;
}

bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayEmptyPos(int index, int tray_index)
{
    if(index >= 0 && tray_index >= 0 && lensTray->getMaterialState(index,tray_index) == MaterialState::IsEmpty)
        return moveToLensTrayPos(index,tray_index);
    if(lensTray->findLastPositionOfState(MaterialState::IsEmpty,tray_index))
        return moveToLensTrayPos(tray_index);
    if(tray_index == 0&&lensTray->findLastPositionOfState(MaterialState::IsEmpty,1))
        return moveToLensTrayPos(1);
    return false;
}

bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayPos(int index, int tray_index)
{
    qInfo("moveToTrayPos");
//    return pick_arm->move_XtXY_Synic(tray->getPositionByIndex(index,tray_index),parameters.visonPositionX());
    return pick_arm->move_XYXmT1_Synic(lensTray->getPositionByIndex(index,tray_index),parameters.visionPositionX(),pick_arm->parameters.pickLensTheta());
}

bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayPos(int tray_index)
{
    qInfo("moveToTrayPos %d",tray_index);
//    return  pick_arm->move_XtXY_Synic(tray->getCurrentPosition(tray_index),parameters.visonPositionX(),false);
    bool result = pick_arm->move_Xm_Origin ();
    result &= pick_arm->move_XYXmT1_Synic(lensTray->getCurrentPosition(tray_index),parameters.visionPositionX(),pick_arm->parameters.pickLensTheta(),false);
    return result;
}


bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayPosT2(int tray_index)
{
    qInfo("moveToTrayPos %d",tray_index);
//    return  pick_arm->move_XtXY_Synic(tray->getCurrentPosition(tray_index),parameters.visonPositionX(),false);
    bool result = pick_arm->move_Xm_Origin ();
    result &= pick_arm->move_XYXmT2_Synic(lensTray->getCurrentPosition(tray_index),parameters.visionPositionX(),pick_arm->parameters.pickLensTheta(),false);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayStartPos(int tray_index)
{
    qInfo("moveToStartPos%d",tray_index);
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XYXm_Synic(lensTray->getStartPosition(tray_index),parameters.visionPositionX(),true);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToLensTrayEndPos()
{
    qInfo("moveToTray1EndPos");
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XYXm_Synic(lensTray->getEndPosition(),parameters.visionPositionX(),true);
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToRejectTrayPos(int index, int tray_index)
{
    qInfo("moveToRejectTrayPos index %d tray_index %d",index,tray_index);
    bool result = pick_arm->move_XY_Synic(rejectTray->getPositionByIndex(index,tray_index));
    if(!result)
        AppendError(QString(u8"移动到reject盘%1号位置失败").arg(index));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToRejectTrayPos(int tray_index)
{
    qInfo("moveToRejectTrayPos tray_index %d",tray_index);
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(rejectTray->getCurrentPosition(tray_index),true);
    if(!result)
        AppendError(QString(u8"移动到reject盘当前位置失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToRejectTrayStartPos(int tray_index)
{
    qInfo("moveToRejectTrayStartPos%d",tray_index);
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(rejectTray->getStartPosition(tray_index),true);
    if(!result)
        AppendError(QString(u8"移动到reject盘起始位置失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToRejectTrayEndPos()
{
    qInfo("moveToRejectTrayEndPos");
    bool result = pick_arm->move_Xm_Origin();
    result &= pick_arm->move_XY_Synic(rejectTray->getEndPosition(),true);
    if(!result)
        AppendError(QString(u8"移动到reject盘结束位置失败"));
    return result;
}

bool SingleHeadMachineMaterialLoaderModule::moveToNextRejectTrayPos(int tray_index)
{
    qInfo("moveToNextRejectTrayPos tray_index %d",tray_index);
    bool result = rejectTray->findNextPositionOfInitState(tray_index);
    if(result)
        result &=  pick_arm->move_XY_Synic(rejectTray->getCurrentPosition(tray_index));
    if(!result)
        AppendError(QString(u8"移动到reject盘下一个位置失败"));
    return result;
}

void SingleHeadMachineMaterialLoaderModule::receiveLoadMaterialRequest(bool need_sensor, bool need_lens, bool has_ng_sensor,
                                                                       bool has_ng_lens, bool has_product)
{
    qInfo("Receive material request, need_sensor: %d need_lens: %d  has_ng_sensor: %d has_ng_lens: %d has_product: %d",
          need_sensor, need_lens, has_ng_sensor, has_ng_lens, has_product);
    this->states.setNeedLoadSensor(need_sensor);
    this->states.setSutHasNgSensor(has_ng_sensor);
    this->states.setNeedLoadLens(need_lens);
    this->states.setLutHasNgLens(has_ng_lens);
    this->states.setSutHasProduct(has_product);
}

void SingleHeadMachineMaterialLoaderModule::run(bool has_material)
{
    is_run = true;
    while (is_run) {
        if (!states.needLoadSensor() && !states.needLoadLens()){  // Waiting for load material
            //May finish the loading, make decision here
            if (this->states.hasPickedLens())    //Place lens to LUT
            {
                moveToLUTPRPos();
                //performLUTLensPR();
                pr_offset.ReSet();               //use this in fast mode
                moveToPicker1WorkPos();
                picker1PlaceLensToLUT();
                states.setHasPickedLens(false);
                states.setLutHasLens(true);
            }

            if (this->states.hasPickedSensor())   //Place sensor to SUT
            {
                moveToSUTPRPos();
                pr_offset.ReSet();
                moveToPicker2WorkPos();           //use this in fast mode
                picker2PlaceSensorToSUT("");
                states.setHasPickedSensor(false);
                states.setSutHasSensor(true);
            }

            if (states.sutHasSensor() && states.lutHasLens())  //Both sensor and lens have already load into sut and lut
            {
                states.setSutHasSensor(false);
                states.setLutHasLens(false);
                emit sendLoadMaterialResponse( sensorTray->getCurrentIndex() , lensTray->getCurrentIndex());
            }
            QThread::msleep(100);
            continue;
        }

        if (this->states.lutHasNgLens()) {   //Pick the ng lens from lut
           moveToLUTPRPos();
           moveToPicker1WorkPos();
           picker1PickNGLensFormLUT();
           this->states.setHasPickedNgLens(true);
        }

        if (this->states.sutHasNgSensor()){  //Pick the ng sensor from sut
            moveToSUTPRPos();
            moveToPicker2WorkPos();
            picker2PickNGSensorFormSUT();
            this->states.setHasPickedNgSensor(true);
        }

        if (this->states.hasPickedNgLens())  // Place the ng lens to tray
        {
            moveToNextLensTrayPos(states.currentLensTray());
            moveToPicker1WorkPos();
            picker1PlaceLensToTray();
            states.setHasPickedNgLens(false);
            lensTray->setCurrentMaterialState(MaterialState::IsNg, states.currentLensTray());
        }

        if (this->states.needLoadLens())
        {
            moveToNextLensTrayPos(states.currentLensTray());
            performLensPR();
            moveToPicker1WorkPos();
            picker1PickLensFormTray();
            states.setHasPickedLens(true);
            states.setNeedLoadLens(false);
        }

        if (this->states.hasPickedNgSensor()) // Place the ng sensor to tray
        {
            moveToNextSensorTrayPos(states.currentSensorTray());
            moveToPicker2WorkPos();
            picker2PlaceSensorToTray();
            states.setHasPickedNgSensor(false);
            sensorTray->setCurrentMaterialState(MaterialState::IsNg, states.currentSensorTray());
        }

        if (this->states.needLoadSensor())
        {
            moveToNextSensorTrayPos(0);
            performSensorPR();
            moveToPicker2WorkPos();
            picker2PickSensorFormTray();
            states.setHasPickedSensor(true);
            states.setNeedLoadSensor(false);
        }
    }
}

bool SingleHeadMachineMaterialLoaderModule::loadLensFromTrayAndPlaceToLUT()
{
    bool ret = false;
    ret = moveToNextLensTrayPos(states.currentLensTray());
    ret &= performLensPR();
    ret &= moveToPicker1WorkPos();
    ret &= picker1PickLensFormTray();
    if (ret) {
        this->states.setHasPickedNgLens(true);
    }
    ret &= moveToLUTPRPos();
    ret &= moveToPicker1WorkPos();
    ret &= picker1PlaceLensToLUT();
    if (ret) {
        this->states.setHasPickedNgLens(false);
    }
    return ret;
}

bool SingleHeadMachineMaterialLoaderModule::pickNgLensFromLUTAndReturnToTray()
{
    bool ret = false;
    ret = moveToLUTPRPos();
    ret &= moveToPicker1WorkPos();
    ret &= picker1PickNGLensFormLUT();
    ret &= moveToNextLensTrayPos(states.currentLensTray());
    //performLensVacancyPR())
    ret &= moveToPicker1WorkPos();
    ret &= picker1PlaceLensToTray();
    return ret;
}
//void SingleHeadMachineMaterialLoaderModule::run(bool has_material)
//{
//    is_run = true;
//    int pr_times = 5;
//    bool has_task = true;
//    bool need_load_lens;
//    bool lut_has_ng_lens;
//    bool waiting_change_lens_tray = false;
//    bool finish_change_lens_tray = false;

//    int sensor_tray_index = 0;
//    int product_tray_index = 1;
//    bool waiting_change_sensor_tray = false;
//    bool finish_change_sensor_tray = false;

//    int change_tray_time_out = parameters.changeTrayTimeOut();
//    while (is_run)
//    {
//        has_task = false;
//        {
//            QMutexLocker temp_locker(&lut_mutex);
//            need_load_lens = states.needLoadLens();
//            lut_has_ng_lens = states.lutHasNgLens();
//        }

//        {
//            QMutexLocker temp_locker(&lens_tray_mutex);
//            waiting_change_lens_tray = states.waitingChangeLensTray();
//            finish_change_lens_tray = states.finishChangeLensTray();
//        }
//        if(!has_task)
//            QThread::msleep(1000);
//        //取Lens料
//        if((!finish_stop)&&states.hasLensTray()&&(!states.allowChangeLensTray())&&(!states.hasPickedNgLens())&&(!states.hasPickedLens()))
//        {
//            has_task = true;
//            if(!moveToNextLensTrayPos(states.currentLensTray()))
//            {
//                AppendError("moveToNextLensTrayPos Pos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if((!performLensPR())&&has_material)
//            {
//                if(pr_times > 0)
//                {
//                    pr_times--;
//                    lensTray->setCurrentMaterialState(MaterialState::IsEmpty,states.currentLensTray());
//                    states.setPickedLensTrayID(states.currentLensTray());
//                    states.setPickedLensID(lensTray->getCurrentIndex(states.currentLensTray()));
//                    continue;
//                }
//                else
//                {
//                    pr_times = 5;
//                    AppendError("performLensPR fial 5 times!");
//                    sendAlarmMessage(ErrorLevel::WarningBlock,GetCurrentError());
//                    waitMessageReturn(is_run);
//                    if(is_run)break;
//                }
//            }
//            if(!moveToPicker1WorkPos())
//            {
//                AppendError("moveToPicker1WorkPos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }

////            if((!pickTrayLens())&&has_material)
//                if((!picker1PickLensFormTray())&&has_material)
//            {
//                AppendError("pickTrayLens fail!");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                if(!waitMessageReturn(is_run))
//                    states.setHasPickedLens(true);
//            }
//            else
//                states.setHasPickedLens(true);
//            lensTray->setCurrentMaterialState(MaterialState::IsEmpty,states.currentLensTray());
//            states.setPickedLensTrayID(states.currentLensTray());
//            states.setPickedLensID(lensTray->getCurrentIndex(states.currentLensTray()));
//            if(!is_run)break;
//        }
//        //放NGLens
//        if(states.hasLensTray()&&(!states.allowChangeLensTray())&&states.hasPickedNgLens())
//        {
//            has_task = true;
//            if(!moveToLensTrayEmptyPos(states.pickedLensID(),states.pickedLensTrayID()))
//            {
//                AppendError("去放NG Lens位置失败，请手动拿走LPA 上的NG Lens!");
//                sendAlarmMessage(ErrorLevel::WarningBlock,GetCurrentError());
//                waitMessageReturn(is_run);
//                //todo加物料检测
//                states.setHasPickedNgLens(false);
//                continue;
//            }
//            if((!performLensVacancyPR())&&has_material)
//            {
//                AppendError(u8"空盘视觉失败！");
//                sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                int result = waitMessageReturn(is_run);
//                if(!result)is_run = false;
//                if(!is_run)break;
//                if(result)
//                    continue;
//            }
//            if(!moveToPicker1WorkPos())
//            {
//                AppendError("moveToPicker1WorkPos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
////            if((!placeLensToTray())&&has_material)
//                  if((!picker1PlaceLensToTray())&&has_material)
//            {
//                AppendError("placeLensToTray fail!");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                waitMessageReturn(is_run);
//            }
//            lensTray->setCurrentMaterialState(MaterialState::IsNg,states.currentLensTray());
//            states.setHasPickedNgLens(false);
//            if(!is_run)break;
//        }
//        //检测是否需要换Lens盘
//        if((!states.allowChangeLensTray()))
//        {
//            if((!states.hasLensTray())||checkNeedChangeLensTray())
//                states.setAllowChangeLensTray(true);
//        }
//        //等待位置
//        //if(!moveToLUTPRPos1())
//        if (!moveToLUTPRPos())
//        {
//            sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//            is_run = false;
//            break;
//        }
//        //执行换Lens盘
//        if(states.allowChangeLensTray())
//        {
//            if(waiting_change_lens_tray)
//            {
//                if(finish_change_lens_tray)
//                {
//                    {
//                        QMutexLocker temp_locker(&lens_tray_mutex);
//                        states.setFinishChangeLensTray(false);
//                        states.setWaitingChangeLensTray(false);
//                    }
//                    lensTray->resetTrayState(0);
//                    lensTray->resetTrayState(1);
//                    states.setNeedChangeLensTray(false);
//                    states.setAllowChangeLensTray(false);
//                    qInfo("finishChangeLensTray");
//                }
//                else
//                {
//                    if(!has_task)
//                        QThread::msleep(1000);
//                    qInfo("waitingChangeTray");
//                    change_tray_time_out -=1000;
//                    if(change_tray_time_out<=0)
//                    {
//                        AppendError(QString(u8"等待换盘超时，超时时间%d,请选择是继续等待或者重新换盘").arg(parameters.changeTrayTimeOut()));
//                        sendAlarmMessage(ErrorLevel::ContinueOrRetry,GetCurrentError());
//                        if(waitMessageReturn(is_run))
//                            states.setWaitingChangeLensTray(false);
//                        else
//                            change_tray_time_out = parameters.changeTrayTimeOut();
//                    }
//                }
//            }
//            else
//            {
//                {
//                    QMutexLocker temp_locker(&lens_tray_mutex);
//                    states.setFinishChangeLensTray(false);
//                    emit sendChangeLensTrayRequst();
//                    states.setWaitingChangeLensTray(true);
//                }
//                change_tray_time_out = parameters.changeTrayTimeOut();
//                qInfo("sendChangeTray");
//            }
//        }
//        //放料到LUT
//        if(need_load_lens&&states.hasPickedLens())
//        {
//            has_task = true;
//            //if(!moveToLUTPRPos1())
//            if(!moveToLUTPRPos())
//            {
//                AppendError("moveToLUTPRPos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if(!moveToPicker1WorkPos())
//            {
//                AppendError("moveToPicker1WorkPos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
////            if((!placeLensToLUT())&&has_material)
//                if((!picker1PlaceLensToLUT())&&has_material)
//            {
//                AppendError("placeLensToLUT fail!");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                if(waitMessageReturn(is_run))
//                    states.setHasPickedLens(false);
//                else
//                {
//                    need_load_lens = false;
//                    states.setHasPickedLens(false);
//                }
//            }
//            else
//            {
//                need_load_lens = false;
//                states.setHasPickedLens(false);
//            }
//            {
//                QMutexLocker temp_locker(&lut_mutex);
//                states.setNeedLoadLens(need_load_lens);
//                states.setLutTrayID(states.pickedLensTrayID());
//                states.setLutLensID(states.pickedLensID());
//            }
//        }
//        //取NGlens
//        if(lut_has_ng_lens&&(!states.hasPickedLens())&&(!states.hasPickedNgLens()))
//        {
//            has_task = true;
//            //if(!moveToLUTPRPos2())
//            if (!moveToLUTPRPos())
//            {
//                AppendError("moveToLUTPRPos2 fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if((!performLUTPR())&&has_material)
//            {
//                AppendError(u8"NG视觉失败！");
//                sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                int result = waitMessageReturn(is_run);
//                if(!result)is_run = false;
//                if(!is_run)break;
//                if(result)
//                    continue;
//            }
//            if(!moveToPicker1WorkPos())
//            {
//                AppendError("moveToPicker1WorkPos fail!");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
////            if((!pickLUTLens())&&has_material)
//                 if((!picker1PickNGLensFormLUT())&&has_material)
//            {
//                AppendError("pickLUTLens fail!");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                if(waitMessageReturn(is_run))
//                    lut_has_ng_lens = false;
//                else
//                    states.setHasPickedNgLens(true);
//            }
//            else
//            {
//                lut_has_ng_lens = false;
//                states.setHasPickedNgLens(true);
//            }
//            {
//                QMutexLocker temp_locker(&lut_mutex);
//                states.setLutHasNgLens(lut_has_ng_lens);
//                states.setPickedLensTrayID(states.lutNgTrayID());
//                states.setPickedLensID(states.lutNgLensID());
//            }
//        }
//        //判断是否完成
//        if((!states.lutHasNgLens())&&(!states.needLoadLens()))
//        {
//            if(states.loadingLens())
//            {
//                QMutexLocker temp_locker(&lut_mutex);
//                emit sendLoadLensFinish(states.lutLensID(),states.lutTrayID());
//                states.setLoadingLens(false);
//            }
//        }

//        {
//            QMutexLocker temp_locker(&sensor_tray_mutex);
//            waiting_change_sensor_tray = states.waitingChangeSensorTray();
//            finish_change_sensor_tray = states.finishChangeSensorTray();
//        }
//        if(!has_task)
//            QThread::msleep(1000);
//        has_task = false;
//        //放成品
//        if((!states.allowChangeSensorTray())&&states.hasSensorTray()&&states.hasPickedProduct())
//        {
//            has_task = true;
//            if(!moveToNextSensorTrayPos(product_tray_index))
//            {
//                AppendError(u8"moveToSensorTrayPos fail");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if((!performSensorVacancyPR())&&has_material)
//            {
//                AppendError(u8"空盘视觉失败！");
//                sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                int result = waitMessageReturn(is_run);
//                if(!result)is_run = false;
//                if(!is_run)break;
//                if(result)
//                    continue;
//            }
//            //if(!moveToWorkPos2())
//            if(!moveToPicker2WorkPos())
//            {
//                AppendError(u8"moveToPicker2WorkPos fail");
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
////            if((!placeProductToTray())&&has_material)
//                 if((!picker2PlaceProductToTray())&&has_material)
//            {
//                AppendError(u8"placeProductToTray fail");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                waitMessageReturn(is_run);
//            }
//            sensorTray->setCurrentMaterialState(MaterialState::IsProduct,product_tray_index);
//            states.setHasPickedProduct(false);
//            if(!is_run)break;
//        }
//        //放NGSensor
//        if((!states.allowChangeSensorTray())&&states.hasSensorTray()&&states.hasPickedNgSensor())
//        {
//            has_task = true;
//            if(!moveToNextSensorTrayPos(product_tray_index))
//            {
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if((!performSensorVacancyPR())&&has_material)
//            {
//                AppendError(u8"空盘视觉失败！");
//                sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                int result = waitMessageReturn(is_run);
//                if(!result)is_run = false;
//                if(!is_run)break;
//                if(result)
//                    continue;
//            }
//            //if(!moveToWorkPos2())
//            if(!moveToPicker2WorkPos())
//            {
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
////            if((!placeSensorToTray())&&has_material)
//                 if((!picker2PlaceSensorToTray())&&has_material)
//            {
//                AppendError(u8"placeProductToTray fail");
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                waitMessageReturn(is_run);
//            }
//            sensorTray->setCurrentMaterialState(MaterialState::IsNg,product_tray_index);
//            states.setHasPickedNgSensor(false);
//            if(!is_run)break;
//        }
//        //取料
//        if((!finish_stop)&&(!states.allowChangeSensorTray())&&states.hasSensorTray()&&(!states.hasPickedSensor())&&(!states.hasPickedProduct())&&(!states.hasPickedNgSensor()))
//        {
//            has_task = true;
//            if(!moveToNextSensorTrayPos(sensor_tray_index))
//            {
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }
//            if((!performSensorPR())&&has_material)
//            {
//                if(pr_times > 0)
//                    {
//                    pr_times--;
//                    sensorTray->setCurrentMaterialState(MaterialState::IsEmpty,sensor_tray_index);
//                    //picked_material = sensorTray->getCurrentIndex(sensor_tray_index);
//                    continue;
//                    }
//                else
//                {
//                    pr_times = 5;
//                    AppendError(u8"pr连续失败五次");
//                    sendAlarmMessage(ErrorLevel::WarningBlock,GetCurrentError());
//                    waitMessageReturn(is_run);
//                    if(is_run)break;
//                }
//            }
//            if(!moveToPicker2WorkPos())
//            {
//                sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                is_run = false;
//                break;
//            }

//            if((!picker2PickSensorFormTray())&&has_material)
//            {
//                sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                if(!waitMessageReturn(is_run))
//                    states.setHasPickedSensor(true);
//            }
//            else
//                states.setHasPickedSensor(true);
//                sensorTray->setCurrentMaterialState(MaterialState::IsEmpty,sensor_tray_index);
//                //picked_material = sensorTray->getCurrentIndex(sensor_tray_index);
//                if(!is_run)break;
//        }
//        //检测是否需要换盘
//        if((!states.allowChangeSensorTray()))
//        {
//            if((!states.hasSensorTray())||checkNeedChangeSensorTray())
//                states.setAllowChangeSensorTray(true);
//        }
//        //等待位置
//        //if(!moveToSUTPRPos(states.beExchangeMaterial()?isLocalHost:(!isLocalHost)))
//        if(!moveToSUTPRPos())
//        {
//            sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//            is_run = false;
//            break;
//        }
//        //执行换盘
//        if(states.allowChangeSensorTray())
//        {
//            if(waiting_change_sensor_tray)
//            {
//                if(finish_change_sensor_tray)
//                {
//                    {
//                        QMutexLocker temp_locker(&sensor_tray_mutex);
//                        states.setFinishChangeSensorTray(false);
//                        states.setWaitingChangeSensorTray(false);
//                    }
//                    sensorTray->resetTrayState(0);
//                    sensorTray->resetTrayState(1);
//                    states.setNeedChangeSensorTray(false);
//                    states.setAllowChangeSensorTray(false);
//                    qInfo("finishChangeSensorTray");
//                }
//                else
//                {
//                    if(!has_task)
//                        QThread::msleep(1000);
//                    qInfo("waitingChangeTray");
//                    change_tray_time_out -=1000;
//                    if(change_tray_time_out<=0)
//                    {
//                        AppendError(QString(u8"等待换盘超时，超时时间%d,请选择是继续等待或者重新换盘").arg(parameters.changeTrayTimeOut()));
//                        sendAlarmMessage(ErrorLevel::ContinueOrRetry,GetCurrentError());
//                        if(waitMessageReturn(is_run))
//                            states.setWaitingChangeSensorTray(false);
//                        else
//                            change_tray_time_out = parameters.changeTrayTimeOut();
//                    }
//                }
//            }
//            else
//            {
//                {
//                    QMutexLocker temp_locker(&sensor_tray_mutex);
//                    states.setFinishChangeSensorTray(false);
//                    emit sendChangeSensorTrayRequst();
//                    states.setWaitingChangeSensorTray(true);
//                }
//                change_tray_time_out = parameters.changeTrayTimeOut();
//                qInfo("sendChangeTray");
//            }
//        }
//        //sut操作
//        if (states.beExchangeMaterial())
//        {
//            has_task = true;
//            while(states.beExchangeMaterial())
//            {
//                if((!states.hasPickedNgSensor())&&(!states.hasPickedProduct()))
//                {
//                    if(!moveToSUTPRPos())
//                    {
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
//                    if((!performSUTProductPR())&&has_material)
//                    {
//                        AppendError(u8"成品视觉失败！");
//                        sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                        int result = waitMessageReturn(is_run);
//                        if(!result)is_run = false;
//                        if(!is_run)break;
//                        if(result)
//                            continue;
//                    }
//                    //if(!moveToWorkPos2())
//                    if(!moveToPicker2WorkPos())
//                    {
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
////                    if((!pickSUTProduct("::1"))&&has_material)
//                         if((!picker2PickProductFormSUT("::1"))&&has_material)
//                    {
//                        sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                        if(waitMessageReturn(is_run))
//                            states.setSutHasProduct(false);
//                        else
//                        {
//                            states.setSutHasProduct(false);
//                            states.setHasPickedProduct(true);
//                        }
//                    }
//                    else
//                    {
//                        states.setSutHasProduct(false);
//                        states.setHasPickedProduct(true);
//                    }
//                }
//                else if((!states.hasPickedNgSensor())&&(!states.hasPickedProduct()))
//                {
//                    //取NG sensor
//                    if(!moveToSUTPRPos())
//                    {
//                        AppendError("moveToSUTPRPos fail!");
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
//                    if((!performSUTSensorPR())&&has_material)
//                    {
//                        AppendError(u8"NG视觉失败！");
//                        sendAlarmMessage(ErrorLevel::RetryOrStop,GetCurrentError());
//                        int result = waitMessageReturn(is_run);
//                        if(!result)is_run = false;
//                        if(!is_run)break;
//                        if(result)
//                            continue;
//                    }
//                    //if(!moveToWorkPos2())
//                    if(!moveToPicker2WorkPos())
//                    {
//                        AppendError("moveToWorkPos2 fail!");
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
////                    if((!pickSUTSensor("::1"))&&has_material)
//                         if((!picker1PickNGSensorFormSUT("::1"))&&has_material)
//                    {
//                        AppendError("pickSUTSensor fail!");
//                        sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                        if(waitMessageReturn(is_run))
//                            states.setSutHasNgSensor(false);
//                        else
//                        {
//                            states.setSutHasNgSensor(false);
//                            states.setHasPickedNgSensor(true);
//                        }
//                    }
//                    else
//                    {
//                        states.setSutHasNgSensor(false);
//                        states.setHasPickedNgSensor(true);
//                    }
//                }
//                else if (states.hasPickedSensor())
//                {
//                    //放料到SUT
//                    if(!moveToSUTPRPos())
//                    {
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
//                    //if(!moveToWorkPos())
//                    if(!moveToPicker2WorkPos())
//                    {
//                        AppendError("moveToPicker2WorkPos fail!");
//                        sendAlarmMessage(ErrorLevel::ErrorMustStop,GetCurrentError());
//                        is_run = false;
//                        break;
//                    }
////                    if((!placeSensorToSUT("::1"))&&has_material)
//                          if((!picker1PlaceSensorToSUT("::1"))&&has_material)
//                    {
//                        sendAlarmMessage(ErrorLevel::ContinueOrGiveUp,GetCurrentError());
//                        if(waitMessageReturn(is_run))
//                        {
//                            states.setHasPickedSensor(false);
//                            break;
//                        }
//                        else
//                        {
//                            states.setNeedLoadSensor(false);
//                            states.setHasPickedSensor(false);
//                            states.setBeExchangeMaterial(false);
//                        }
//                    }
//                    else
//                    {
//                        states.setNeedLoadSensor(false);
//                        states.setHasPickedSensor(false);
//                        states.setBeExchangeMaterial(false);
//                    }
//                }
//                else if((states.hasPickedNgSensor()||states.hasPickedProduct())||(!states.hasPickedSensor()))
//                {
//                    break;
//                }
//            }
//            }
//    }
//    qInfo("SensorLoader stoped");
//}

void SingleHeadMachineMaterialLoaderModule::startWork(int run_mode)
{
    qInfo("MaterailLoader start run_mode :%d in %d", run_mode, QThread::currentThreadId());
    if (run_mode == RunMode::Normal)
       run(true);
}

void SingleHeadMachineMaterialLoaderModule::stopWork(bool wait_finish)
{
    qInfo("MaterailLoader stop Work");
    is_run = false;
}

void SingleHeadMachineMaterialLoaderModule::resetLogic()
{
    qInfo("resetLogic is called");
    this->states.setLutHasLens(false);
    this->states.setLutHasNgLens(false);
    this->states.setLoadingLens(false);
    lensTray->resetTrayState();
}

void SingleHeadMachineMaterialLoaderModule::performHandlingOperation(int cmd)
{
    qInfo("performHandling %d",cmd);
    bool result;
//    int curren
    int handlePosition = cmd&HANDLE_POSITION;
    switch (handlePosition){
    case LENS_TRAY1:
    {
        qInfo("lpa move to lensTray1's current position, cmd: %d",LENS_TRAY1);
        result = moveToLensTrayPos(0);
    }
        break;
    case LENS_TRAY1_PICKER2:
    {
        qInfo("lpa move to lensTray1's current position, cmd: %d",LENS_TRAY1);
        result = moveToLensTrayPosT2(0);
    }
        break;
    case LENS_TRAY2:
    {
        qInfo("lpa move to lensTray2's current position, cmd: %d",LENS_TRAY2);
        result = moveToLensTrayPos(1);
    }
        break;
    case LUT_PR_POS:
    {
        qInfo("lpa move to LUT position,cmd: %d",LUT_PR_POS);
        result = moveToLUTPRPos();
    }
        break;
    case LENS_TRAY1_START_POS:
    {
        qInfo("lpa move to tray1 start position,cmd: %d",LENS_TRAY1_START_POS);
        result = moveToLensTrayStartPos(0);
    }
        break;
    case LENS_TRAY2_START_POS:
    {
        qInfo("lpa move to tray2 start position,cmd: %d",LENS_TRAY2_START_POS);
        result = moveToLensTrayStartPos(1);
    }
        break;
    case LENS_TRAY1_END_POS:
    {
        qInfo("lpa move to tray1 end position,cmd: %d",LENS_TRAY1_END_POS);
        result = moveToLensTrayEndPos();
    }
        break;
    case UPDOWNLOOK_DOWN_POS:
    {
        qInfo("UPDOWNLOOK_DOWN_POS");
        result = true;
    }
        break;
    case UPDOWNLOOK_UP_POS:
    {
        qInfo("UNPDOWNLOOK_UP_POS");
        result = true;
    }
        break;
    case SENSOR_TRAY:
    {
        qInfo("spa move to sensor tray current position,cmd: %d",SENSOR_TRAY);
        result = moveToSensorTrayPos(0);
    }
        break;
    case SUT_PR_POS:
    {
        qInfo("spa move to sut position,cmd: %d",SUT_PR_POS);
        result = moveToSUTPRPos();
    }
        break;
    case SENSOR_TRAY_START_POS:
    {
        qInfo("spa move to sensor tray start position,cmd: %d",SENSOR_TRAY_START_POS);
        result = moveToSensorTrayStartPos(0);
    }
        break;
    case SENSOR_TRAY_END_POS:
    {
        qInfo("spa move to snesor tray end position,cmd: %d",SENSOR_TRAY_END_POS);
        result = moveToSensorTrayEndPos();
    }
        break;
    case REJECT_TRAY:
    {
        qInfo("spa move to reject tray current position,cmd: %d",REJECT_TRAY);
        result = moveToRejectTrayPos(0);
    }
        break;
    case REJECT_TRAY_START_POS:
    {
        qInfo("spa move to reject tray start position,cmd: %d",REJECT_TRAY_START_POS);
        result = moveToRejectTrayStartPos(0);
    }
        break;
    case REJECT_TRAY_END_POS:
    {
        qInfo("spa move to reject tray end position,cmd: %d",REJECT_TRAY_END_POS);
        result = moveToRejectTrayEndPos();
    }
        break;
    default:
        result = true;
        break;
    }
    if(!result)
    {
        sendAlarmMessage(ErrorLevel::TipNonblock,GetCurrentError());
        return;
    }
    int handlePR = cmd&HANDLE_PR;
    switch (handlePR) {
    case RESET_PR:
    {
        qInfo("reset PR result,cmd: %d",RESET_PR);
        pr_offset.ReSet();
    }
        break;
    case SENSOR_PR:
    {
        qInfo("perform sensor PR,cmd: %d",SENSOR_PR);
        result = performSensorPR();
    }
        break;
    case SENSOR_VACANCY_PR:
    {
        qInfo("perform sensor tray vacancy PR, cmd: %d",SENSOR_VACANCY_PR);
        result = performSensorVacancyPR();
    }
        break;
    case SUT_PR:
    {
        qInfo("perform SUT vacancy PR,cmd: %d",SUT_PR);
        result = performSUTPR();
    }
        break;
    case NG_SENSOR_PR:
    {
        qInfo("perform SUT Ng Sensor PR,cmd: %d",NG_SENSOR_PR);
        result = performSUTSensorPR();
    }
        break;
    case PRODUCT_PR:
    {
        qInfo("perform SUT product PR,cmd: %d",PRODUCT_PR);
        result = performSUTProductPR();
    }
        break;
    case LENS_PR:
    {
        qInfo("perform lens PR,cmd: %d",LENS_PR);
        result = performLensPR();
    }
        break;
    case NG_LENS_PR:
    {
        qInfo("perform ng lens PR, cmd: %d",NG_LENS_PR);
        result = performLUTLensPR();
    }
    case LENS_VACANCY_PR:
    {
        qInfo("perform lens tray vacancy PR,cmd: %d",LENS_VACANCY_PR);
        result = performLensVacancyPR();
    }
        break;
    case LUT_PR:
    {
        qInfo("perform LUT vacancy PR,cmd: %d",LUT_PR);
        result = performLUTPR();
    }
        break;
    case UPDOWNLOOK_DOWN_PR:
    {
        qInfo("UPDOWNLOOK_DOWN_PR");
    }
        break;
    case LENS_PICKER_PR:
    {
        qInfo("perform lens suction PR");
    }
        break;
    case REJECT_VACANCY_PR:
        {
            qInfo("perform reject tray vacancy PR, cmd: %d",REJECT_VACANCY_PR);
            result = performSensorVacancyPR();
        }
            break;
    default:
        result = true;
        break;
    }
    if(!result)
    {
        sendAlarmMessage(ErrorLevel::TipNonblock,GetCurrentError());
        return;
    }
    int handleToWorkPos = cmd&HANDLE_TO_WORKPOS;
    switch (handleToWorkPos) {
    case PICKER1_TO_WORKPOS:
    {
        qInfo("lens suction move offset,cmd: %d",PICKER1_TO_WORKPOS);
        result = moveToPicker1WorkPos();
    }
        break;
    case PICKER2_TO_WORKPOS:
    {
        qInfo("lens suction move offset,cmd: %d",PICKER1_TO_WORKPOS);
        result = moveToPicker2WorkPos();
    }
        break;
    case LPA_TO_PROFFSET:
    {
        qInfo("LPA_TO_PROFFSET");
    }
        break;

    case SENSOR_TO_PR_OFFSET:
    {
        qInfo("SENSOR_TO_PR_OFFSET");
    }
        break;
    default:
        result = true;
        break;
    }
    if(!result)
    {
        //        finished_type = FinishedType::Alarm;
        qInfo("Move To Work Pos fail");
        return;
    }
    int handlePickerAction = cmd&HANDLE_PICKER_ACTION;
    switch (handlePickerAction) {
    case PICK_SENSOR_FROM_TRAY:
    {
        qInfo("move to pick sensor from tray,cmd: %d",PICK_SENSOR_FROM_TRAY);
        result = picker2PickSensorFormTray();
    }
        break;
    case PICK_SENSOR_FROM_TRAY1:
    {
        qInfo("move to pick sensor from tray,cmd: %d",PICK_SENSOR_FROM_TRAY);
        result = picker1PickSensorFormTray();
    }
        break;
    case PICKER1_PLACE_SENSOR_TO_SUT:
    {
        qInfo("move to place sensor to SUT,cmd: %d",PICKER1_PLACE_SENSOR_TO_SUT);
//        result = placeSensorToSUT("remote");
         result = picker1PlaceSensorToSUT("remote");
    }
        break;
    case PICKER2_PLACE_SENSOR_TO_SUT:
    {
        qInfo("move to place sensor to SUT,cmd: %d",PICKER2_PLACE_SENSOR_TO_SUT);
        result = picker2PlaceSensorToSUT("remote");
    }
        break;

    case PICK_NG_SENSOR_FROM_SUT:
    {
        qInfo("move to pick ngSensor from SUT,cmd: %d",PICK_NG_SENSOR_FROM_SUT);
        //result = picker1PickNGSensorFormSUT("remote");
        result = picker2PickNGSensorFormSUT();
    }
        break;
    case PICKER1_PICK_NG_SENSOR_FROM_SUT:
    {
        qInfo("move to pick ngSensor from SUT,cmd: %d",PICK_NG_SENSOR_FROM_SUT);
        result = picker1PickNGSensorFormSUT("remote");
    }
        break;
    case PLACE_NG_SENSOR_TO_TRAY:
    {
        qInfo("move to place sensor to tray,cmd: %d",PLACE_NG_SENSOR_TO_TRAY);
        result = picker2PlaceNGSensorToTray();
    }
        break;
    case PLACE_NG_SENSOR_TO_TRAY1:
    {
        qInfo("move to place sensor to tray,cmd: %d",PLACE_NG_SENSOR_TO_TRAY);
        result = picker1PlaceNGSensorToTray();
    }
        break;
    case PICKER2_PICK_PRODUCT_FROM_SUT:
    {
        qInfo("move to pick product form sut,cmd: %d",PICK_PRODUCT_FROM_SUT);
        result = picker2PickProductFormSUT("remote");
    }
        break;
    case PLACE_PRODUCT_TO_TRAY:
    {
        qInfo("move to place product to tray,cmd: %d",PLACE_PRODUCT_TO_TRAY);
        result = picker2PlaceProductToTray();
    }
        break;
    case MEASURE_SENSOR_IN_TRAY:
    {
        qInfo("mesure pick senso from tray height, cmd: %d",MEASURE_SENSOR_IN_TRAY);
        result = picker2MeasureHight(true,false,false);

    }
        break;
    case MEASURE_NG_SENSOR_IN_TRAY:
    {
        qInfo("measure place ng sensor to tray height, cmd: %d",MEASURE_NG_SENSOR_IN_TRAY);
        result = picker2MeasureHight(true,false);
    }
        break;
    case MEASURE_PRODUCT_IN_TRAY:
    {
        qInfo("measure place product to tray height, cmd: %d ",MEASURE_PRODUCT_IN_TRAY);
        result = picker1MeasureHight(true,true);
    }
        break;
    case MEASURE_SENSOR_IN_SUT:
    {
        qInfo("measure place sensor to SUT,cmd: %d",MEASURE_SENSOR_IN_SUT);
        result = picker2MeasureHight(false,false,false);
    }
        break;
    case MEASURE_NG_SENSOR_IN_SUT:
    {
        qInfo("measure pick ng sensor from SUT, cmd: %d",MEASURE_NG_SENSOR_IN_SUT);
        result = picker2MeasureHight(false,false);
    }
        break;
    case MEASURE_PRODUCT_IN_SUT:
    {
        qInfo("measure pick product form SUT, cmd: %d",MEASURE_PRODUCT_IN_SUT);
        result = picker2MeasureHight(false,true,false);
    }
        break;
    case PICK_LENS_FROM_TRAY:
    {
        qInfo("pick lens form tray, cmd: %d",PICK_LENS_FROM_TRAY);
        result = picker1PickLensFormTray();
    }
        break;
    case PICK_LENS_FROM_TRAY_PICKER2:
    {
        qInfo("pick lens form tray, cmd: %d",PICK_LENS_FROM_TRAY);
        result = picker2PickLensFormTray();
    }
        break;
    case PLACE_LENS_TO_LUT:
    {
        qInfo("place lens to SUT,cmd: %d",PLACE_LENS_TO_LUT);
        result = picker1PlaceLensToLUT();
    }
        break;
    case PICK_NG_LENS_FROM_LUT:
    {
        qInfo("pick ng lens from LUT,cmd: %d",PICK_NG_LENS_FROM_LUT);
        result = picker1PickNGLensFormLUT();
    }
        break;
    case PLACE_NG_LENS_TO_TRAY:
    {
        qInfo("place ng lens to tray,cmd: %d",PLACE_NG_LENS_TO_TRAY);
        result = picker1PlaceLensToTray();
    }
        break;
    case PLACE_NG_LENS_TO_TRAY1:
    {
        qInfo("place ng lens to tray,cmd: %d",PLACE_NG_LENS_TO_TRAY);
        result = picker2PlaceLensToTray();
    }
        break;
    case MEASURE_LENS_IN_TRAY:
    {
        qInfo("measure pick lens from tray height,cmd: %d",MEASURE_LENS_IN_TRAY);
        result = picker1MeasureHight(true);
    }
        break;
    case MEASURE_LENS_IN_LUT:
    {
        qInfo("measuer place lens to LUT height,cmd: %d",MEASURE_LENS_IN_LUT);
        result = picker1MeasureHight(false);
    }
        break;
    default:
        result = true;
        break;
    }
    return;
}

